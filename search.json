[{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing guidelines","title":"Contributing guidelines","text":"encounter bug, please report GitHub Issues. Ideally, provide minimal reproducible example (.e. lines code can copy--paste R console obtain error).","code":""},{"path":"/articles/abstract.html","id":"title","dir":"Articles","previous_headings":"","what":"Title","title":"Abstract","text":"Penalised regression multiple sources prior effects","code":""},{"path":"/articles/abstract.html","id":"authors","dir":"Articles","previous_headings":"","what":"Authors","title":"Abstract","text":"Armin Rauschenberger\\(~^{1,}\\) Zied Landoulsi\\(~^{1}\\) Mark . van de Wiel\\(~^{2,b}\\) Enrico Glaab\\(~^{1,b}\\) \\(^1\\)Luxembourg Centre Systems Biomedicine (LCSB), University Luxembourg, Esch-sur-Alzette, Luxembourg. \\(^2\\)Department Epidemiology Data Science (EDS), Amsterdam University Medical Centers (Amsterdam UMC), Amsterdam, Netherlands. \\(^{}\\)correspondence addressed. \\(^{b}\\)Mark . van de Wiel Enrico Glaab share senior authorship.","code":""},{"path":"/articles/abstract.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Abstract","text":"many high-dimensional prediction classification tasks, complementary data features available, e.g. prior biological knowledge (epi)genetic markers. consider tasks numerical prior information provide insight importance (weight) direction (sign) feature effects, e.g. regression coefficients previous studies. propose approach integrating multiple sources prior information penalised regression. suitable co-data available, improves predictive performance, shown simulation application. proposed method implemented R package `transreg’ (https://github.com/lcsb-bds/transreg).","code":""},{"path":"/articles/abstract.html","id":"pre-print","dir":"Articles","previous_headings":"","what":"Pre-print","title":"Abstract","text":"arXiv: 2212.08581 (pdf) ORBi: 10993/53227 (pdf)","code":""},{"path":"/articles/analysis.html","id":"initialisation","dir":"Articles","previous_headings":"","what":"Initialisation","title":"Analysis","text":"Choose directory containing sub-directories “data”, “results” “manuscript”. directory “data” may empty first external application (script loads data - also available - R package GRridge) must contain file “pone.0181468.s001.csv” second external application (available Erez et al. 2017 supporting file journal.pone.0181468.s001.csv) files “vcf_with_pvalue.tab” “LuxPark_pheno.txt” internal application (available upon request request.ncer-pd@uni.lu). internal application, directory also contain intermediate file “app_int_data.RData”. directory “results” contain files “sim_int.RData” “sim_ext.RData” external internal simulation, file “app_grridge.RData” first external application, file “app_fwelnet.RData” second external application, file “app_int.RData” internal application. directory “manuscript” contain files “table_int.tex” “table_ext.tex” internal external simulations, file “figure_example.pdf” methods section, file “figure_ext.pdf” external applications, file “figure_int.pdf” internal application. Install missing R packages CRAN GitHub. Note ecpc transreg also available CRAN. package versions, see session information end document text files associated R data file.","code":"rm(list=ls()) dir <- \"~/Desktop/transreg\" # physical machine #dir <- \"/home/armin.rauschenberger/transreg\" # virtual machine setwd(dir) if(!all(c(\"data\",\"results\",\"manuscript\") %in% dir())){  stop(\"Missing folders!\")  } pkgs <- c(\"devtools\",\"palasso\",\"glmtrans\",\"xtable\",\"ecpc\",\"xrnet\") utils::install.packages(setdiff(pkgs,rownames(installed.packages()))) remotes::install_github(\"markvdwiel/GRridge\") # ref=\"ef706afe\", version 1.7.5 remotes::install_github(\"kjytay/fwelnet\") # ref=\"5515fd2e\", version 0.1 remotes::install_github(\"LCSB-BDS/transreg\") # ref=\"82757441\", version 1.0.0 rm(pkgs)"},{"path":"/articles/analysis.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Analysis","text":"following chunk generates figure methods section. input: none (simulating data) execution time: seconds output: manuscript/figure_example.pdf","code":"#<<init>> grDevices::pdf(file=paste0(dir,\"/manuscript/figure_example.pdf\"),width=8,height=5,pointsize=15)  set.seed(1) n <- 200; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) temp <- stats::rnorm(p) range <- stats::qnorm(p=c(0.01,0.99)) temp[temp<range[1]] <- range[1] temp[temp>range[2]] <- range[2]  beta <- list() beta$ident <- temp beta$sqrt <- sign(temp)*sqrt(abs(temp)) beta$quad <- sign(temp)*abs(temp)^2 beta$trunc <- ifelse(temp<=0,0,temp) beta$step <- ifelse(temp<=1,0,1) beta$combn <- ifelse(temp<0,sign(temp)*sqrt(abs(temp)),sign(temp)*abs(temp)^2)  graphics::par(mfrow=c(2,3),mar=c(3,3,0.5,0.5)) for(i in seq_along(beta)){      prior <- matrix(temp,ncol=1)   eta <- X %*% beta[[i]]   y <- stats::rnorm(n=n,mean=eta,sd=sd(eta))   a <- transreg:::.exp.multiple(y=y,X=X,prior=prior,family=\"gaussian\",select=FALSE)   b <- transreg:::.iso.fast.single(y=y,X=X,prior=prior,family=\"gaussian\")    graphics::plot.new()   graphics::plot.window(xlim=range(prior,-prior),ylim=range(a$beta,b$beta))   graphics::axis(side=1)   graphics::axis(side=2)   graphics::abline(h=0,lty=2,col=\"grey\")   graphics::abline(v=0,lty=2,col=\"grey\")   graphics::box()   graphics::title(xlab=expression(z),ylab=expression(gamma),line=2)   graphics::points(x=prior,y=a$beta,col=\"red\",cex=0.7)   graphics::points(x=prior,y=b$beta,col=\"blue\",cex=0.7)   graphics::lines(x=prior[order(prior)],y=beta[[i]][order(prior)],lwd=1.2)   graphics::legend(x=\"topleft\",legend=paste0(\"(\",i,\")\"),bty=\"n\",x.intersp=0) }  grDevices::dev.off()"},{"path":"/articles/analysis.html","id":"simulations","dir":"Articles","previous_headings":"","what":"Simulations","title":"Analysis","text":"following chunk performs external (glmtrans) internal simulation. input: none (simulating data) execution time: 2 + 1 = 3 hours output: results/sim_ext.RData, results/sim_int.RData, results/info_sim.RData following chunk generates tables external (glmtrans) internal simulation. Requires execution previous chunk. input: results/sim_ext.RData, results/sim_int.RData execution time: seconds output: manuscript/table_ext.tex, manuscript/table_int.tex","code":"#<<init>>  # - - - modify glmtrans::models function - - - glmtrans.models <- glmtrans::models string <- base::deparse(glmtrans.models) # return target beta string <- gsub(pattern=\"list\\\\(x \\\\= NULL, y \\\\= NULL\\\\)\",                replacement=\"list(x = NULL, y = NULL, beta = wk)\",                x=string) # return source beta string <- gsub(pattern=\"list\\\\(x \\\\= x, y \\\\= y\\\\)\",                replacement=\"list(x = x, y = y, beta = wk)\",                x=string) glmtrans.models <- eval(parse(text=string)) rm(string) # - - - - - - - - - - - - - - - - - - - - - -  for(mode in c(\"ext\",\"int\")){        # simulation setting     if(mode==\"ext\"){       frame <- expand.grid(seed=1:10,                            Ka=as.integer(c(1,3,5)),                            K=as.integer(5),                            h=as.integer(c(5,250)),                            alpha=as.integer(c(0,1)),                            family=c(\"gaussian\",\"binomial\")                            )     } else if(mode==\"int\"){       frame <- expand.grid(seed=1:10,                            rho.x=c(0.95,0.99),                            rho.beta=c(0.6,0.8,0.99),                            alpha=as.integer(c(0,1)),                            family=c(\"gaussian\",\"binomial\")                            )     }     frame$family <- as.character(frame$family)     frame[,c(\"cor.x\",\"cor.beta\",\"mean\",\"glmnet\",\"glmtrans\",\"transreg\")] <- NA     n0 <- 100; n1 <- 10000     n.target <- n0+n1     foldid.ext <- rep(c(0,1),times=c(n0,n1))          for(iter in seq_len(nrow(frame))){       cat(paste0(mode,\": \",iter,\"/\",nrow(frame),\"\\n\"))              if(!is.na(frame$seed[iter])){set.seed(frame$seed[iter])}        # data simulation       if(mode==\"ext\"){          message(\"Using external simulation study!\")         s <- ifelse(frame$alpha[iter]==0,50,15)         data <- glmtrans.models(family=frame$family[iter],type=\"all\",                                 p=1000,n.target=n.target,s=s,                                 Ka=frame$Ka[iter],K=frame$K[iter],h=frame$h[iter])         target <- data$target         source <- data$source         beta <- cbind(sapply(data$source,function(x) x$beta),data$target$beta)       } else if(mode==\"int\"){         message(\"Using internal simulation study!\")         prop <- ifelse(frame$alpha[iter]==0,0.3,0.05)         data <- transreg:::simulate(p=500,n.target=n.target,family=frame$family[iter],                                 prop=prop,rho.beta=frame$rho.beta[iter],w=0.8,                                 rho.x=frame$rho.x[iter],k=3,exp=c(1,2,0.5),                                 trans=c(FALSE,TRUE,TRUE))         target <- data$target         source <- data$source         beta <- data$beta       }              # correlation       temp <- abs(stats::cor(data$target$x,method=\"pearson\"))       temp[lower.tri(temp,diag=TRUE)] <- NA       frame$cor.x[iter] <- mean(temp,na.rm=TRUE)       temp <- abs(stats::cor(beta,method=\"pearson\"))       temp[lower.tri(temp,diag=TRUE)] <- NA       frame$cor.beta[iter] <- max(temp[,ncol(temp)],na.rm=TRUE)              # predictive performance       loss <- transreg:::compare(target=target,source=source,                           family=frame$family[iter],alpha=frame$alpha[iter],                           foldid.ext=foldid.ext,nfolds.ext=1,                           scale=c(\"exp\",\"iso\"),                           sign=FALSE,switch=FALSE,select=TRUE,alpha.prior=NULL,                           seed=frame$seed[iter],xrnet=TRUE)       frame[iter,names(loss$deviance)] <- loss$deviance     }     save(frame,file=paste0(dir,\"/results/sim_\",mode,\".RData\")) } writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_sim.txt\")) rm(list=ls()) dir <- \"~/Desktop/transreg\" # physical machine #dir <- \"/home/armin.rauschenberger/transreg\" # virtual machine setwd(dir) if(!all(c(\"data\",\"results\",\"manuscript\") %in% dir())){  stop(\"Missing folders!\")  } for(mode in c(\"ext\",\"int\")){     file <- paste0(dir,\"/results/sim_\",mode,\".RData\")     #if(mode==\"int\"){file <- \"~/Desktop/transreg/results/sim_int_fast.RData\"}     if(!file.exists(file)){warning(\"Missing file \",file,\".\");next}     load(file)     colnames(frame) <- gsub(pattern=\"transreg.\",replacement=\"\",x=colnames(frame))          info.var <- c(\"Ka\",\"h\",\"rho.x\",\"rho.beta\",\"alpha\",\"family\")     info <- frame[,colnames(frame) %in% info.var]     info.name <- gsub(pattern=\" \",replacement=\"\",x=apply(info,1,function(x) paste0(x,collapse=\".\")))     number <- as.numeric(factor(info.name,levels=unique(info.name)))     info <- unique(info)     info$cor.beta <- info$cor.x <- NA          loss.var <- c(\"glmnet\",\"glmtrans\",\"xrnet\",\"exp.sta\",\"exp.sim\",\"iso.sta\",\"iso.sim\")     loss <- frame[,c(loss.var,\"mean\")]     # as percentage of empty model     loss <- 100*loss/loss$mean        # average over 10 different seeds     both <- mean <- sd <- p.better <- p.worse <- matrix(NA,nrow=max(number),ncol=length(loss.var),dimnames=list(1:max(number),loss.var))     for(i in 1:max(number)){       for(j in seq_along(loss.var)){         cond <- number==i         x <- loss$glmnet[cond]         y <- loss[[loss.var[j]]][cond]         p.better[i,j] <- stats::wilcox.test(x=x,y=y,paired=TRUE,alternative=\"greater\",exact=FALSE)$p.value         p.worse[i,j] <- stats::wilcox.test(x=x,y=y,paired=TRUE,alternative=\"less\",exact=FALSE)$p.value         mean[i,j] <- mean(y)         sd[i,j] <- sd(y)         info$cor.x[i] <- mean(frame$cor.x[cond])         info$cor.beta[i] <- mean(frame$cor.beta[cond])       }     }          front <- format(round(mean,digits=1),trim=TRUE)     front.nchar <- nchar(front)     back <- format(round(sd,digits=1),trim=TRUE)     back.nchar <- nchar(back)          both[] <- paste0(front,\"$\\\\pm$\",back)          grey <- mean>=mean[,\"glmnet\"]     both[grey] <- paste0(\"\\\\textcolor{gray}{\",both[grey],\"}\")          min <- cbind(seq_len(max(number)),apply(mean,1,which.min))     both[min] <- paste0(\"\\\\underline{\",both[min],\"}\")      star <- p.better<=0.05     both[star] <- paste0(both[star],\"*\")     #both[!star] <- paste0(both[!star],\"\\\\phantom{*}\")           dagger <- p.worse<=0.05     both[dagger] <- paste0(both[dagger],\"$\\\\dagger$\")     both[!star & !dagger] <- paste0(both[!star & !dagger],\"\\\\phantom{*}\")           both[front.nchar==3] <- paste0(\"$~$\",both[front.nchar==3])     both[back.nchar==3] <- paste0(both[back.nchar==3],\"$~$\")          external <- \"number of transferable source data sets ($K_a$), differences between source and target coefficients ($h$), dense setting with ridge regularisation ($s=50$, $\\\\alpha=0$) or sparse setting with lasso regularisation ($s=15$, $\\\\alpha=1$), family of distribution (`gaussian' or `binomial').\"     internal <- \"correlation parameter for features ($\\\\rho_x$), correlation parameter for coefficients ($\\\\rho_{\\\\beta}$), dense setting with ridge regularisation ($\\\\pi=30\\\\%$, $\\\\alpha=0$) or sparse setting with lasso regularisation ($\\\\pi=5\\\\%$, $\\\\alpha=1$), family of distribution (`gaussian' or `binomial').\"     caption <- paste0(\"Predictive performance in \",mode,\"ernal simulation. In each setting (row), we simulate $10$ data sets, calculate the performance metric (mean-squared error for numerical prediction, logistic deviance for binary classification) for the test sets, express these metrics as percentages of those from prediction by the mean, and show the mean and standard deviation of these percentages. Settings: \",ifelse(mode==\"ext\",external,ifelse(mode==\"int\",internal,NULL)),\" These parameters determine (i) the mean Pearson correlation among the features in the target data set ($\\\\bar{\\\\rho}_x$) and (ii) the maximum Pearson correlation between the coefficients in the target data set and the coefficients in the source data sets ($\\\\max(\\\\hat{\\\\rho}_{\\\\beta})$). Methods: regularised regression (\\\\texttt{glmnet}), competing transfer learning methods (\\\\texttt{glmtrans} , \\\\texttt{xrnet}), proposed transfer learning method (\\\\texttt{transreg}) with exponential/isotonic calibration and standard/simultaneous stacking. In each setting, the colour black (grey) highlights methods that are more (less) predictive than regularised regression without transfer learning (\\\\texttt{glmnet}), asterisks (daggers) indicate methods that are \\\\textit{significantly} more (less) predictive at the 5\\\\% level (one-sided Wilcoxon signed-rank test), and an underline highlights the most predictive method. \\\\label{sim_\",mode,\"}\")          colnames(info) <- sapply(colnames(info),function(x) switch(x,\"Ka\"=\"$K_a$\",\"K\"=\"$K$\",\"h\"=\"$h$\",\"alpha\"=\"$\\\\alpha$\",\"rho.x\"=\"$\\\\rho_x$\",\"rho.beta\"=\"$\\\\rho_\\\\beta$\",\"cor.x\"=\"$\\\\bar{\\\\rho}_{x}$\",\"cor.beta\"=\"$\\\\max(\\\\hat{\\\\rho}_{\\\\beta})$\",\"cor.t\"=\"$\\\\bar{\\\\rho}_{a}$\",x))     colnames(both) <- paste0(\"\\\\texttt{\",colnames(both),\"}\")          align <- paste0(\"|r|\",paste0(rep(\"c\",times=ncol(info)),collapse=\"\"),\"|\",paste0(rep(\"c\",times=ncol(both)),collapse=\"\"),\"|\")          add.to.row <- list()     add.to.row$pos <- list(-1)     add.to.row$command <- \"\\\\multicolumn{9}{c}{~} & \\\\multicolumn{4}{|c|}{\\\\texttt{transreg}}\\\\\\\\\"          xtable <- xtable::xtable(x=cbind(info,both),align=align,caption=caption)     xtable::print.xtable(x=xtable,                 include.rownames=FALSE,                 floating=TRUE,                 sanitize.text.function=identity,                 comment=FALSE,                 caption.placement=\"top\",                 floating.environment=\"table*\",                 #size=\"\\\\small \\\\setlength{\\\\tabcolsep}{3pt}\",                 file=paste0(dir,\"/manuscript/table_\",mode,\".tex\"),                 add.to.row=add.to.row,                 hline.after=c(-1,0,nrow(xtable))) }"},{"path":"/articles/analysis.html","id":"external-applications","dir":"Articles","previous_headings":"","what":"External applications","title":"Analysis","text":"following chunk performs first external application (GRridge). input: none (script loads data - also available - R package GRridge) execution time: 2.5 hours output: results/app_grridge.RData, results/info_app_grridge.txt following chunk performs second external application (fwelnet). input: data/pone.0181468.s001.csv (available Erez et al. 2017 supporting file journal.pone.0181468.s001.csv) execution time: 0.5 hours output: results/app_fwelnet.RData, results/info_app_fwelnet.txt following chunk generates figure external applications (GRridge fwelnet). Requires execution previous two chunks. input: results/app_grridge.RData, results/app_fwelnet.RData execution time: seconds output: manuscript/figure_ext.pdf","code":"#<<init>> data(dataVerlaat,package=\"GRridge\")  target <- list() target$y <- as.numeric(as.factor(respVerlaat))-1 target$x <- t(datcenVerlaat)  z <- -log10(pvalFarkas) # ecpc and fwelnet prior <- sign(diffmeanFarkas)*(-log10(pvalFarkas)) # transreg  loss <- list() for(i in 1:10){   cat(\"---\",i,\"---\\n\")   loss[[i]] <- transreg:::compare(target=target,prior=prior,z=as.matrix(z,ncol=1),                                     family=\"binomial\",alpha=0,scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=i,xrnet=TRUE) } save(loss,file=paste0(dir,\"/results/app_grridge.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_grridge.txt\"))  load(paste0(dir,\"/results/app_grridge.RData\"),verbose=TRUE) table <- as.data.frame(t(sapply(loss,function(x) x$deviance))) table <- (table-table$glmnet)/table$glmnet table <- table[,c(\"glmnet\",\"transreg.exp.sta\",\"transreg.exp.sim\",\"transreg.iso.sta\",\"transreg.iso.sim\",\"fwelnet\",\"ecpc\",\"xrnet\")] sapply(table[,-1],function(x) sum(x<table$glmnet)) round(100*colMeans(table[,-1]),digits=2) #<<init>>  table <- utils::read.csv(\"data/pone.0181468.s001.csv\",header=TRUE,skip=3)  extract <- function(cond,y,X,id){   if(length(unique(c(length(cond),length(y),nrow(X),length(id))))!=1){stop(\"Invalid input.\")}   n <- table(id,cond)[,\"TRUE\"]   y <- y[cond]   X <- X[cond,]   id <- id[cond]   weights <- rep(1/n,times=n)   ids <- unique(id)   ys <- sapply(ids,function(x) unique(y[id==x]))   foldid <- rep(NA,length=length(ids))   foldid[ys==0] <- sample(rep(1:10,length.out=sum(ys==0)))   foldid[ys==1] <- sample(rep(1:10,length.out=sum(ys==1)))   foldid <- rep(foldid,times=n[n!=0])   if(length(unique(c(length(y),nrow(X),length(weights),length(foldid))))!=1){     stop(\"Invalid output.\")   }   return(list(y=y,x=X,weights=weights,foldid=foldid)) }  loss <- ridge <- lasso <- list() for(i in 1:10){   cat(\"---\",i,\"---\\n\")   set.seed(i)      y <- table$LatePE   X <- as.matrix(table[,grepl(pattern=\"SL\",x=colnames(table))])   X <- scale(X)      min <- sapply(unique(table$ID),function(i) min(table$GA[table$ID==i]))   max <- sapply(unique(table$ID),function(i) max(table$GA[table$ID==i]))      limit <- 20   group <- stats::rbinom(n=max(table$ID),size=1,prob=0.5)   source.id <- which(group==0 | min > limit)   target.id <- which(group==1 & min <= limit)   if(any(!table$ID %in% c(source.id,target.id))){stop()}   if(any(!c(source.id,target.id) %in% table$ID)){stop()}   if(any(duplicated(c(source.id,target.id)))){stop()}      source <- list()   source[[1]] <- extract(cond=(table$ID %in% source.id) & (table$GA<=limit),y=y,X=X,id=table$ID)   source[[2]] <- extract(cond=(table$ID %in% source.id),y=y,X=X,id=table$ID)      prior <- z <- matrix(NA,nrow=ncol(X),ncol=length(source))   for(j in seq_along(source)){     base <- glmnet::cv.glmnet(y=source[[j]]$y,x=source[[j]]$x,                               family=\"binomial\",alpha=0,                               weights=source[[j]]$weights,                               foldid=source[[j]]$foldid)     prior[,j] <- coef(base,s=\"lambda.min\")[-1]     z[,j] <- abs(coef(base,s=\"lambda.min\")[-1])   }      target <- list()   target$y <- sapply(target.id,function(i) unique(y[table$ID==i]))   target$x <- t(sapply(target.id,function(i) X[table$ID==i & table$GA==min(table$GA[table$ID==i]),]))      loss[[i]] <- transreg:::compare(target=target,prior=prior,family=\"binomial\",alpha=0,scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,z=z,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=i,xrnet=TRUE) } save(loss,file=paste0(dir,\"/results/app_fwelnet.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_fwelnet.txt\"))  load(paste0(dir,\"/results/app_fwelnet.RData\")) table <- as.data.frame(t(sapply(loss,function(x) x$deviance))) table <- (table-table$glmnet)/table$glmnet table <- table[,c(\"glmnet\",\"transreg.exp.sta\",\"transreg.exp.sim\",\"transreg.iso.sta\",\"transreg.iso.sim\",\"fwelnet\",\"ecpc\",\"xrnet\")] sapply(table[,-1],function(x) sum(x<table$glmnet)) round(100*colMeans(table[,-1]),digits=2) grDevices::pdf(file=paste0(dir,\"/manuscript/figure_ext.pdf\"),width=8,height=6,pointsize=15) graphics::par(mfrow=c(2,1),mar=c(2.5,3.5,0.5,0.5)) for(k in c(\"grridge\",\"fwelnet\")){   file <- paste0(dir,\"/results/app_\",k,\".RData\")   if(!file.exists(file)){plot.new();next}   load(file)   loss <- as.data.frame(t(sapply(loss,function(x) x$deviance)))   colnames(loss) <- gsub(pattern=\"transreg.\",replacement=\"\",x=colnames(loss))   loss <- 100*(loss-loss$glmnet)/loss$glmnet    temp <- c(\"exp.sta\",\"exp.sim\",\"iso.sta\",\"iso.sim\")   name <- c(\"fwelnet\",\"ecpc\",\"xrnet\",temp)   graphics::plot.new()   graphics::plot.window(xlim=c(0.5,length(name)+0.5),ylim=range(loss,na.rm=TRUE))   graphics::abline(h=0,lty=2,col=\"grey\")   #graphics::axis(side=1,at=seq_along(name),labels=name,cex.axis=0.7) # original   cond <- grepl(pattern=\"\\\\.\",x=name)   graphics::axis(side=1,at=seq_along(name),labels=rep(\"\",times=length(name)))   graphics::mtext(side=1,at=seq_along(name)[!cond],text=name[!cond],cex=0.7,line=1)   graphics::mtext(side=1,at=seq_along(name)[cond],text=name[cond],cex=0.7,line=0.25)   graphics::mtext(side=1,at=mean(seq_along(name)[cond]),text=\"transreg\",cex=0.7,line=1)      if(grepl(pattern=\"grridge\",x=k)){at <- seq(from=-10,to=10,by=5)}   if(grepl(pattern=\"fwelnet\",x=k)){at <- seq(from=-20,to=20,by=10)}   labels <- ifelse(at==0,\"0%\",ifelse(at<0,paste0(at,\"%\"),paste0(\"+\",at,\"%\")))   graphics::axis(side=2,cex.axis=0.7,at=at,labels=labels)   graphics::title(ylab=\"change in metric\",line=2.5,cex.lab=0.7)   graphics::box()   for(i in seq_along(name)){     palasso:::.boxplot(loss[,name[i]],at=i,invert=FALSE)     graphics::points(x=i,y=mean(loss[,name[i]]),pch=22,col=\"white\",bg=\"black\",cex=0.7)   } } grDevices::dev.off()"},{"path":"/articles/analysis.html","id":"internal-application","dir":"Articles","previous_headings":"","what":"Internal application","title":"Analysis","text":"following chunk performs internal application. input: data/vcf_with_pvalue.tab, data/LuxPark_pheno.txt (available upon request request.ncer-pd@uni.lu) execution time: 5.5 hours (parallel computing 8 cores) output: data/app_int_data.RData, results/app_int.RData, results/info_app_int.txt following chunk generates figures internal application. Requires execution previous chunk. input: results/app_int.RData execution time: seconds output: manuscript/figure_int.pdf, manuscript/figure_temp.pdf","code":"#<<init>> geno <- read.table(paste0(dir,\"/data/vcf_with_pvalue.tab\"),header=TRUE)  switch <- ifelse(geno$REF==geno$A1_gwas & geno$ALT==geno$A2_gwas,1,                  ifelse(geno$REF==geno$A2_gwas & geno$ALT==geno$A1_gwas,-1,0)) #prior <- -geno$beta*switch # original effect sizes prior <- log10(geno$p_value)*sign(geno$beta)*switch # pseudo effect sizes pvalue <- geno$p_value  # Note: Why are pseudo-effect sizes more suitable as prior effects as compared to original effect sizes? # graphics::plot(x=geno$beta,y=-log10(geno$p_value),xlim=c(-1,1),col=ifelse(stats::p.adjust(geno$p_value)<=0.05,\"red\",\"black\"))  X <- geno[,grepl(pattern=\"ND\",colnames(geno))] X[X==\"0/0\"] <- 0 X[X==\"0/1\"] <- 1 X[X==\"1/1\"] <- 1 X <- sapply(X,as.numeric) X <- t(X)  pheno <- read.delim(paste0(dir,\"/data/LuxPark_pheno.txt\"),sep=\" \",header=FALSE) y <- ifelse(pheno$V2==1,0,ifelse(pheno$V2==2,1,NA)); names(y) <- pheno$V1  names <- intersect(names(y[!is.na(y)]),rownames(X)) X <- X[names,]; y <- y[names]  # Note: Are prior effects positively correlated with correlation between outcome and features? # cor <- as.numeric(stats::cor(y,X,method=\"spearman\")) # graphics::plot(x=prior,y=cor,col=ifelse(stats::p.adjust(geno$p_value)<=0.05,\"red\",\"black\")) # graphics::abline(h=0,lty=2,col=\"grey\")  # descriptive statistics sum(p.adjust(pvalue,method=\"BH\")<=0.05) sum(p.adjust(pvalue,method=\"holm\")<=0.05) mean(pvalue<=0.05) dim(X) table(y)  # memory reduction cond <- pvalue <= 0.05 X <- X[,cond] prior <- prior[cond] pvalue <- pvalue[cond] switch <- switch[cond]  save(y,X,prior,pvalue,switch,file=paste0(dir,\"/data/app_int_data.RData\"))  load(paste0(dir,\"/data/app_int_data.RData\")) power <- seq(from=-2,to=-10,by=-1) cutoff <- 5*10^power frame <- expand.grid(cutoff=cutoff,alpha=0:1,seed=1:10,count=NA)  #- - - sequential (start) - - - #loss <- list() #for(i in seq_len(nrow(frame))){ #  cat(\"--- i =\",i,\"---\",\"\\n\") #  set.seed(frame$seed[i]) #  foldid <- transreg:::.folds(y=y,nfolds.ext=10,nfolds.int=10) #  cond <- switch!=0 & pvalue < frame$cutoff[i] #  loss[[i]] <- transreg:::compare(target=list(y=y,x=X[,cond]),prior=prior[cond],family=\"binomial\",alpha=frame$alpha[i],scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,foldid.ext=foldid$foldid.ext,foldid.int=foldid$foldid.int,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=frame$seed[i]) #  frame$count[i] <- sum(cond) #} # - - - sequential (end) - - -  #- - - parallel (start) - - - frame <- expand.grid(cutoff=cutoff,alpha=0:1,seed=1:10,count=NA) cluster <- snow::makeCluster(8) evaluate <- function(frame,i,switch,pvalue,y,X,prior){   set.seed(frame$seed[i])   foldid <- transreg:::.folds(y=y,nfolds.ext=10,nfolds.int=10)   cond <- switch!=0 & pvalue < frame$cutoff[i]   transreg:::compare(target=list(y=y,x=X[,cond]),prior=prior[cond],family=\"binomial\",alpha=frame$alpha[i],scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,foldid.ext=foldid$foldid.ext,foldid.int=foldid$foldid.int,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=frame$seed[i]) } snow::clusterExport(cl=cluster,list=c(\"evaluate\",\"frame\",\"switch\",\"pvalue\",\"y\",\"X\",\"prior\")) loss <- snow::parSapply(cl=cluster,X=seq_len(nrow(frame)),FUN=function(i) evaluate(frame=frame,i=i,switch=switch,pvalue=pvalue,y=y,X=X,prior=prior),simplify=FALSE) #- - - parallel (end) - - -  save(frame,loss,file=paste0(dir,\"/results/app_int.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_int.txt\")) #<<init>>  plotter <- function(table,cutoff,number,horizontal=FALSE){   graphics::par(mfrow=c(2,2),mar=c(3,1.8,1.0,0.9))   for(scale in c(\"exp\",\"iso\")){     for(alpha in c(\"0\",\"1\")){       graphics::plot.new()       graphics::plot.window(xlim=range(log(cutoff)),ylim=range(table))       graphics::box()       graphics::title(main=paste(ifelse(alpha==0,\"ridge\",ifelse(alpha==1,\"lasso\",NA)),\"-\",scale),cex.main=1,line=0.2)       on <- rep(c(TRUE,FALSE),length.out=length(cutoff))       graphics::axis(side=1,at=log(cutoff),labels=rep(\"\",times=length(on)),cex.axis=0.7)       graphics::axis(side=1,at=log(cutoff)[on],labels=paste0(cutoff[on],\"\\n\",\"(\",number[on],\")\"),cex.axis=0.7)       graphics::axis(side=2,cex.axis=0.7)       if(horizontal){         graphics::abline(h=0.5,col=\"grey\",lty=2)         #graphics::abline(h=unique(table[[\"mean\"]][,alpha]),col=\"grey\",lty=2)       }       for(i in 1:3){         for(method in c(\"glmnet\",paste0(\"transreg.\",scale,c(\".sta\",\".sim\")),\"naive\")){           lty <- switch(method,\"mean\"=1,\"glmnet\"=1,\"transreg.exp.sta\"=2,\"transreg.exp.sim\"=2,\"transreg.iso.sta\"=2,\"transreg.iso.sim\"=2,\"naive\"=3)           col <- switch(method,\"mean\"=\"grey\",\"glmnet\"=\"black\",\"transreg.exp.sta\"=rgb(0.2,0.2,1),\"transreg.iso.sta\"=rgb(0.2,0.2,1),\"transreg.exp.sim\"=rgb(0,0,0.6),\"transreg.iso.sim\"=rgb(0,0,0.6),\"naive\"=\"red\")           y <- table[[method]][,alpha]           x <- log(as.numeric(names(y)))           if(i==1){graphics::lines(x=x,y=y,col=col,lty=lty)}           if(i==2){graphics::points(x=x,y=y,col=\"white\",pch=16)}           if(i==3){graphics::points(x=x,y=y,col=col)}         }       }     }   } }  load(paste0(dir,\"/data/app_int_data.RData\")) load(paste0(dir,\"/results/app_int.RData\")) frame <- frame[seq_along(loss),colnames(frame)!=\"seed\"] cutoff <- unique(frame$cutoff) number <- unique(sapply(loss,function(x) x$p))  auc <- as.data.frame(t(sapply(loss,function(x) x$auc))) table <- lapply(auc,function(x) tapply(X=x,INDEX=list(frame$cutoff,frame$alpha),FUN=function(x) mean(x)))  grDevices::pdf(file=paste0(dir,\"/manuscript/figure_int.pdf\"),width=8,height=6,pointsize=15) plotter(table,cutoff,number,horizontal=TRUE) grDevices::dev.off()"},{"path":"/articles/analysis.html","id":"acknowledgements","dir":"Articles","previous_headings":"","what":"Acknowledgements","title":"Analysis","text":"Reformat list consortium members acknowledgements: [see source].","code":""},{"path":"/articles/analysis.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Analysis","text":"Print session information.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Armin Rauschenberger. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Armin Rauschenberger, Zied Landoulsi, Mark . van de Wiel, Enrico Glaab (2023). \"Penalised regression  multiple sources prior effects\", arXiv (pre-print) https://doi.org/10.48550/arXiv.2212.08581","code":"@Article{,   title = {Penalised regression with multiple sources of prior effects},   author = {{Rauschenberger, Armin [aut],Landoulsi, Zied [aut],van de Wiel, Mark A. [aut], Glaab, Enrico [aut]}},   journal = {aRxiv},   year = {2023},   doi = {10.48550/arXiv.2212.08581}, }"},{"path":"/index.html","id":"penalised-regression-with-multiple-sets-of-prior-effects","dir":"","previous_headings":"","what":"Penalised regression with multiple sets of prior effects","title":"Penalised Regression with Multiple Sets of Prior Effects","text":"Improves predictive performance ridge lasso regression exploiting one sources prior information importance direction effects.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Penalised Regression with Multiple Sets of Prior Effects","text":"Install current release CRAN: latest development version GitHub GitLab:","code":"#install.packages(\"transreg\") # not yet released! #install.packages(\"remotes\") remotes::install_github(\"lcsb-bds/transreg\") # upstream remotes::install_github(\"rauschenberger/transreg\") # fork remotes::install_gitlab(\"bds/transreg\",host=\"gitlab.lcsb.uni.lu\") # mirror"},{"path":"/index.html","id":"reproducibility","dir":"","previous_headings":"","what":"Reproducibility","title":"Penalised Regression with Multiple Sets of Prior Effects","text":"code reproducing simulations applications shown manuscript available vignette (https://lcsb-bds.github.io/transreg/articles/analysis.html). installing package remotes::intall_github(\"lcsb-bds/transreg\",build_vignettes=TRUE) restarting R, vignette can also loaded vignette(topic=\"analysis\",package=\"transreg\").","code":""},{"path":"/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Penalised Regression with Multiple Sets of Prior Effects","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). ‘Penalised regression multiple sets prior effects’. Manuscript preparation. (arXiv: 2212.08581)","code":""},{"path":"/index.html","id":"disclaimer","dir":"","previous_headings":"","what":"Disclaimer","title":"Penalised Regression with Multiple Sets of Prior Effects","text":"R package transreg implements penalised regression multiple sources prior effects (Rauschenberger et al., 2022). Copyright © 2022 Armin Rauschenberger, University Luxembourg, Luxembourg Centre Systems Biomedicine (LCSB), Biomedical Data Science (BDS) program free software: can redistribute /modify terms GNU General Public License published Free Software Foundation, either version 3 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. received copy GNU General Public License along program. , see http://www.gnu.org/licenses/.","code":""},{"path":"/license.html","id":"gnu-general-public-license","dir":"","previous_headings":"","what":"GNU GENERAL PUBLIC LICENSE","title":"NA","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"/license.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"NA","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"/license.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"NA","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"/license.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"NA","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"/license.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"NA","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"/license.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"NA","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"/license.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"NA","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"/license.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"NA","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"/license.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"NA","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"/license.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"NA","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"/license.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"NA","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"/license.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"NA","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"/license.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"NA","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"/license.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"NA","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"/license.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"NA","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"/license.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License.","title":"NA","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"/license.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"NA","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"/license.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"NA","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"/license.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"NA","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"/license.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"NA","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"/license.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"NA","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands `show w’ `show c’ show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see https://www.gnu.org/licenses/. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read https://www.gnu.org/licenses/--lgpl.html.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation, either version 3 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author>     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.     This is free software, and you are welcome to redistribute it     under certain conditions; type `show c' for details."},{"path":"/reference/calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — calibrate","title":"Internal functions — calibrate","text":"Internal functions called transreg(), depending choice exponential isotonic calibration.","code":""},{"path":"/reference/calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — calibrate","text":"","code":".exp.multiple(   y,   X,   prior,   family,   switch = FALSE,   select = TRUE,   track = FALSE )  .iso.multiple(   y,   X,   prior,   family,   switch = FALSE,   select = TRUE,   track = FALSE )  .iso.fast.single(y, X, prior, family)  .iso.slow.single(y, X, prior, family)"},{"path":"/reference/calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — calibrate","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); switch choose positive negative weights source: logical select select sources: logical track show intermediate output (messages plots): logical","code":""},{"path":"/reference/calibrate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — calibrate","text":".exp.multiple(): called transreg scale=\"exp\" .iso.multiple(): called transreg scale=\"iso\" .iso.fast.single(): called transreg scale=\"iso\" (via .iso.multiple) .iso.slow.single(): replaced .iso.fast.single","code":""},{"path":[]},{"path":"/reference/coef.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Coefficients — coef.transreg","title":"Extract Coefficients — coef.transreg","text":"Extracts coefficients object class transreg.","code":""},{"path":"/reference/coef.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Coefficients — coef.transreg","text":"","code":"# S3 method for transreg coef(object, stack = NULL, ...)"},{"path":"/reference/coef.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Coefficients — coef.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/coef.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Coefficients — coef.transreg","text":"Returns estimated coefficients. output list two slots: slot alpha estimated intercept (scalar), slot beta estimated slopes (vector).","code":""},{"path":"/reference/coef.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract Coefficients — coef.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/coef.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Coefficients — coef.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- glmnet (without prior effects) --- object <- glmnet::cv.glmnet(y=y,x=X,alpha=0) beta_hat <- coef(object,s=\"lambda.min\")[-1] mean((beta-beta_hat)^2) #> [1] 0.8051971  #--- transreg (with prior effects) --- object <- transreg(y=y,X=X,prior=prior,alpha=0) beta_hat <- coef(object)$beta mean((beta-beta_hat)^2) # decrease in MSE? #> [1] 0.4545027"},{"path":"/reference/compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation (reproducibility) — compare","title":"Cross-validation (reproducibility) — compare","text":"Function reproducing hold-method (simulation) \\(k\\)-fold cross-validation (application). See vignette.","code":""},{"path":"/reference/compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation (reproducibility) — compare","text":"","code":"compare(   target,   source = NULL,   prior = NULL,   z = NULL,   family,   alpha,   scale = \"iso\",   sign = FALSE,   switch = FALSE,   select = TRUE,   foldid.ext = NULL,   nfolds.ext = 10,   foldid.int = NULL,   nfolds.int = 10,   type.measure = \"deviance\",   alpha.prior = NULL,   naive = TRUE,   seed = NULL,   cores = 1,   xrnet = FALSE )"},{"path":"/reference/compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation (reproducibility) — compare","text":"target list slot x (feature matrix n rows p columns) slot y (target vector length n) source list k lists, slot x (feature matrix m_i rows p columns) slot y (target vector length m_i) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) z prior weights family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 scale character \"exp\" exponential calibration \"iso\" isotonic calibration sign sign discovery procedure: logical (experimental argument) switch choose positive negative weights source: logical select select sources: logical foldid.ext external fold identifiers nfolds.ext number external folds foldid.int internal fold identifiers nfolds.int number internal folds type.measure character alpha.prior alpha source regression naive compare naive transfer learning: logical seed random seed cores number cores parallel computing (requires R package doMC) xrnet compare xrnet: logical","code":""},{"path":[]},{"path":"/reference/dot-residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — .residuals","title":"Calculate residuals — .residuals","text":"Calculates residuals observed outcome predicted values (Gaussian family) predicted probabilities (binomial family). Called .exp.multiple .iso.multiple.","code":""},{"path":"/reference/dot-residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — .residuals","text":"","code":".residuals(y, y_hat, family)"},{"path":"/reference/dot-residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — .residuals","text":"y response: vector length \\(n\\) (see family) y_hat predicted values probabilities (see family): vector length \\(n\\), matrix \\(n\\) rows (samples) \\(k\\) columns (methods) family character \"gaussian\" (\\(y\\): real numbers, \\(y_hat\\): real numbers) \"binomial\" (\\(y\\): 0s 1s, \\(y_hat\\): unit interval)","code":""},{"path":"/reference/dot-residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate residuals — .residuals","text":"","code":"n <- 100 p <- 5 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) #y <- stats::rbinom(n,size=1,prob=0.5) y <- stats::rnorm(n) glm <- glm(y~X,family=\"gaussian\") res <- residuals.glm(glm) y_hat <- predict(glm,type=\"response\") all.equal(res,y-y_hat) #> [1] TRUE"},{"path":"/reference/dot-signdisc.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign discovery — .signdisc","title":"Sign discovery — .signdisc","text":"Assigns signs prior weights obtain prior coefficients","code":""},{"path":"/reference/dot-signdisc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign discovery — .signdisc","text":"","code":".signdisc(y, X, prior, family, foldid = NULL, nfolds = 10, track = FALSE)"},{"path":"/reference/dot-signdisc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign discovery — .signdisc","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer track show intermediate output (messages plots): logical","code":""},{"path":"/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — extract","title":"Internal functions — extract","text":"Internal functions called coef.transreg(), predict.transreg() weights.transreg(), depending choice standard stacking simultaneous stacking.","code":""},{"path":"/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — extract","text":"","code":".predict.sta(object, newx, ...)  .predict.sim(object, newx, ...)  .coef.sta(object, ...)  .coef.sim(object, ...)  .weights.sta(object, ...)  .weights.sim(object, ...)  .which.stack(object, stack)"},{"path":"/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — extract","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) ... (applicable) stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking)","code":""},{"path":"/reference/extract.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — extract","text":".predict.sta(): called predict.transreg stack=\"sta\" .predict.sim(): called predict.transreg stack=\"sim\" .coef.sta(): called coef.transreg stack=\"sta\" .coef.sim(): called coef.transreg stack=\"sim\" .weights.sta(): called weights.transreg stack=\"sta\" .weights.sim(): called weights.transreg stack=\"sim\" ..stack(): called coef.transreg, predict.transreg weights.transreg","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values — fitted.transreg","title":"Fitted values — fitted.transreg","text":"Extracts fitted values","code":""},{"path":"/reference/fitted.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values — fitted.transreg","text":"","code":"# S3 method for transreg fitted(object, stack = NULL, ...)"},{"path":"/reference/fitted.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values — fitted.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/fitted.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values — fitted.transreg","text":"Returns fitted values. output numerical vector one entry sample.","code":""},{"path":"/reference/fitted.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitted values — fitted.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values — fitted.transreg","text":"","code":"#--- simulation --- set.seed(1) n0 <- 100; n1 <- 10000; n <- n0 + n1; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- train-test split --- foldid <- rep(c(0,1),times=c(n0,n1)) y0 <- y[foldid==0] X0 <- X[foldid==0,] y1 <- y[foldid==1] X1 <- X[foldid==1,]  object <- transreg(y=y0,X=X0,prior=prior)  #--- fitted values --- y0_hat <- fitted(object) mean((y0-y0_hat)^2) #> [1] 112.1512  #--- predicted values --- y1_hat <- predict(object,newx=X1) mean((y1-y1_hat)^2) # increase in MSE? #> [1] 270.4335"},{"path":"/reference/plot.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot transreg-object — plot.transreg","title":"Plot transreg-object — plot.transreg","text":"Plot transreg-object","code":""},{"path":"/reference/plot.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot transreg-object — plot.transreg","text":"","code":"# S3 method for transreg plot(x, stack = NULL, ...)"},{"path":"/reference/plot.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot transreg-object — plot.transreg","text":"x object type transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/plot.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot transreg-object — plot.transreg","text":"Returns four plots. top-left: Calibrated prior effects (\\(y\\)-axis) original prior effects (\\(x\\)-axis). line one source prior effects, colour given grDevices::palette() (black: 1, red: 2, green: 3, blue: 4, ...). top-right: Estimated coefficients transfer learning (\\(y\\)-axis) estimated coefficients without transfer learning (\\(x\\)-axis). point represents one feature. bottom-left: Estimated weights sources prior effects (labels 1 \\(k\\)), either estimated weights lambda.min lambda.1se models (standard stacking) estimated weights features (simultaneous stacking). bottom-right: Absolute deviance residuals (\\(y\\)-axis) fitted values (\\(x\\)-axis). point represents one sample.","code":""},{"path":"/reference/plot.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot transreg-object — plot.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/plot.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot transreg-object — plot.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) #*rbinom(n=n,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) prior3 <- rnorm(p) prior4 <- rnorm(p) y <- X %*% beta  prior <- cbind(prior1,prior2,prior3,prior4) object <- transreg(y=y,X=X,prior=prior,alpha=0,stack=c(\"sta\",\"sim\"))  plot(object,stack=\"sta\")"},{"path":"/reference/predict.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Predictions — predict.transreg","title":"Make Predictions — predict.transreg","text":"Predicts outcome","code":""},{"path":"/reference/predict.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Predictions — predict.transreg","text":"","code":"# S3 method for transreg predict(object, newx, stack = NULL, ...)"},{"path":"/reference/predict.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Predictions — predict.transreg","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/predict.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Predictions — predict.transreg","text":"Returns predicted values predicted probabilities. output column vector one entry sample.","code":""},{"path":"/reference/predict.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Make Predictions — predict.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/predict.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make Predictions — predict.transreg","text":"","code":"#--- simulation --- set.seed(1) n0 <- 100; n1 <- 10000; n <- n0 + n1; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- train-test split --- foldid <- rep(c(0,1),times=c(n0,n1)) y0 <- y[foldid==0] X0 <- X[foldid==0,] y1 <- y[foldid==1] X1 <- X[foldid==1,]  #--- glmnet (without prior effects) --- object <- glmnet::cv.glmnet(y=y0,x=X0) y_hat <- predict(object,newx=X1,s=\"lambda.min\") mean((y1-y_hat)^2) #> [1] 493.8406  #--- transreg (with prior effects) --- object <- transreg(y=y0,X=X0,prior=prior) y_hat <- predict(object,newx=X1) mean((y1-y_hat)^2) # decrease in MSE? #> [1] 265.7714"},{"path":"/reference/print.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print transreg-object — print.transreg","title":"Print transreg-object — print.transreg","text":"Show summary transreg-object","code":""},{"path":"/reference/print.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print transreg-object — print.transreg","text":"","code":"# S3 method for transreg print(x, ...)"},{"path":"/reference/print.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print transreg-object — print.transreg","text":"x object class transreg ... (applicable)","code":""},{"path":"/reference/print.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print transreg-object — print.transreg","text":"Returns family distributions, elastic net mixing parameter (\\(alpha\\)), number samples (\\(n\\)), number features (\\(p\\)), number sources co-data (\\(k\\)), chosen calibration method (exponential isotonic), chosen stacking method (standard simultaneous).","code":""},{"path":"/reference/print.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print transreg-object — print.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- print.transreg  --- object <- transreg(y=y,X=X,prior=prior) object #> ----- transreg-object ----- #> family: 'gaussian' #> alpha = 1 (lasso) #> n = 100 (samples) #> p = 500 (features) #> k = 1 (sources of co-data) #> calibration: 'iso' #> stacking: 'sim'  #> ---------------------------"},{"path":"/reference/simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation (reproducibility) — simulate","title":"Simulation (reproducibility) — simulate","text":"Function reproducing 'internal' simulation study. See vignette.","code":""},{"path":"/reference/simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation (reproducibility) — simulate","text":"","code":"simulate(   p = 1000,   n.target = 100,   n.source = 150,   k = 2,   family = \"gaussian\",   prop = 0.01,   rho.beta = 0.95,   rho.x = 0.95,   w = 0.5,   trans = rep(TRUE, times = k),   exp = rep(1, times = k) )"},{"path":"/reference/simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation (reproducibility) — simulate","text":"p number features n.target sample size target data set n.source sample size(s) source data set(s), scalar vector length k k number source data sets family \"Gaussian\", \"binomial\" \"poisson\" prop approximate proportion features effects rho.beta correlation effects (across different data sets) rho.x base decreasing correlation structure correlation features w weight signal noise trans logical vector length \\(k\\): transferable (TRUE) non-transferable (FALSE) source exp non-negative vector length \\(k\\) transforming beta sign(beta)*abs(beta)^exp","code":""},{"path":[]},{"path":"/reference/transreg-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg-package","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"R package transreg implements penalised regression multiple sets prior effects.","code":""},{"path":"/reference/transreg-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Use function transreg() model fitting. Type library(transreg) ?transreg help(\"transreg\") open help file. See vignette examples. Type vignette(\"transreg\") browseVignettes(\"transreg\") open vignette.","code":""},{"path":"/reference/transreg-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":"/reference/transreg-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"","code":"?transreg ?predict.transreg ?coef.transreg"},{"path":"/reference/transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Implements penalised regression multiple sets prior effects","code":""},{"path":"/reference/transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"transreg(   y,   X,   prior,   family = \"gaussian\",   alpha = 1,   foldid = NULL,   nfolds = 10,   scale = \"iso\",   stack = \"sim\",   sign = FALSE,   switch = FALSE,   select = TRUE,   track = FALSE,   parallel = FALSE )"},{"path":"/reference/transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalised regression with multiple sets of prior effects — transreg","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer scale character \"exp\" exponential calibration \"iso\" isotonic calibration stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) sign sign discovery procedure: logical (experimental argument) switch choose positive negative weights source: logical select select sources: logical track show intermediate output (messages plots): logical parallel logical (see cv.glmnet)","code":""},{"path":"/reference/transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Returns object class transreg. Rather accessing slots (see list ), recommended use methods like coef.transreg() predict.transreg(). slot base: Object class glmnet. Regression outcome features (without prior effects), \\(1 + p\\) estimated coefficients (intercept + features). slot meta.sta: NULL object class glmnet. Regression outcome cross-validated linear predictors prior effects estimated effects, \\(1 + k + 2\\) estimated coefficients (intercept + sources co-data + lambda_min lambda_1se). slot meta.sim: NULL object class glmnet. Regression outcome meta-features (cross-validated linear predictors prior effects) original features, \\(1 + k + p\\) estimated coefficients (intercept + sources co-data + features). slot prior.calib: Calibrated prior effects. Matrix \\(p\\) rows \\(k\\) columns. slot data: Original data. List slots y, X prior (see arguments). slot info: Information call. Data frame entries \\(n\\), \\(p\\), \\(k\\), family, alpha, scale stack (see details arguments).","code":""},{"path":"/reference/transreg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg","text":"\\(n\\): sample size \\(p\\): number features \\(k\\): number sources","code":""},{"path":"/reference/transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) weights(one) #> [1] 0.6724394 weights(two) #> [1] 0.6208604 0.5642326  # \\donttest{ #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- standard vs simultaneous stacking --- prior <- c(prior1[1:250],rep(0,250)) sta <- transreg(y=y_lin,X=X,prior=prior,stack=\"sta\") sim <- transreg(y=y_lin,X=X,prior=prior,stack=\"sim\") plot(x=coef(sta$base)[-1],y=coef(sta)$beta)  plot(x=coef(sim$base)[-1],y=coef(sim)$beta)# }"},{"path":"/reference/weights.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Weights — weights.transreg","title":"Extract Weights — weights.transreg","text":"Extracts weights object class transreg.","code":""},{"path":"/reference/weights.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Weights — weights.transreg","text":"","code":"# S3 method for transreg weights(object, stack = NULL, ...)"},{"path":"/reference/weights.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Weights — weights.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/weights.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Weights — weights.transreg","text":"Returns weights. output numerical vector one entry source co-data.","code":""},{"path":"/reference/weights.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract Weights — weights.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark . van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. doi:10.48550/arXiv.2212.08581  armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/weights.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Weights — weights.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- cbind(beta+rnorm(p),beta+rnorm(p),rnorm(p),rnorm(p)) y <- X %*% beta  #--- example --- object <- transreg(y=y,X=X,prior=prior) weights(object) #> [1] 0.5647605 0.6181596 0.0000000 0.1233377"},{"path":"/news/index.html","id":"transreg-100-2023-10-01","dir":"Changelog","previous_headings":"","what":"transreg 1.0.0 (2023-10-01)","title":"transreg 1.0.0 (2023-10-01)","text":"CRAN release: 2023-10-01 first release","code":""},{"path":"/news/index.html","id":"transreg-001-2022-08-04","dir":"Changelog","previous_headings":"","what":"transreg 0.0.1 (2022-08-04)","title":"transreg 0.0.1 (2022-08-04)","text":"first public commit","code":""}]
